!! SYMFILE #L14Words 0x00020901 #L14Words.%main 1
!! TYPE #Tree !0 POINTER
!! TARGET 0 !1 RECORD #L14Words.Node 32 VOID
!!   FIELD #word 0 !2 ARRAY 20 CHAR
!!   FIELD #count 20 INTEGER
!!   FIELD #left 24 0
!!   FIELD #right 28 0;
!! TYPE #Node 1
!! DEF !3 FLEX CHAR
!! PROCEDURE #IncWord 22 #L14Words.IncWord !4 PROC 3 VOID
!!   VPARAM #s 12 3
!!   VPARAM #p 20 0;
!!     LOCAL #q -4 0;
!! PROCEDURE #Output 52 #L14Words.Output !5 PROC 1 VOID
!!   PARAM #p 12 0;
!!     LOCAL #sp -4 INTEGER
!!     LOCAL #stack -4004 !6 ARRAY 1000 0;
!! PROCEDURE #Main 71 #L14Words.Main !7 PROC 0 VOID;
!!     LOCAL #word -20 !8 ARRAY 20 CHAR
!!     LOCAL #root -24 0;
!! END 0x36bf9633
!! 
MODULE L14Words 0x36bf9633 88
IMPORT In 0x598dbea3
IMPORT Out 0x7c0066d9
ENDHDR

PROC L14Words.IncWord 1 20 0x00510001
! PROCEDURE IncWord(VAR s: ARRAY OF CHAR; VAR p: Tree);
LINE 22
!   IF (p = NIL) THEN
LINE 25
LDLW 20
LOADW
JNEQZ 2
!     NEW(q); 
LINE 26
CONST 32
CONST L14Words.Node
LOCAL -4
CONST NEW
CALL 3
!     COPY(s, q.word); q.count := 1; 
LINE 27
LDLW -4
NCHECK 27
CONST 20
SWAP
LDLW 16
LDLW 12
CONST COPY
CALL 4
CONST 1
LDLW -4
NCHECK 27
STNW 20
!     q.left := NIL; q.right := NIL;
LINE 28
CONST 0
LDLW -4
NCHECK 28
STNW 24
CONST 0
LDLW -4
NCHECK 28
STNW 28
!     p := q
LINE 29
LDLW -4
LDLW 20
STOREW
RETURN
LABEL 2
!   ELSIF p.word = s THEN
LINE 30
LDLW 16
LDLW 12
LDLW 20
LOADW
NCHECK 30
CONST 20
SWAP
CONST COMPARE
CALLW 4
JNEQZ 3
!     p.count := p.count + 1
LINE 31
LDLW 20
LOADW
NCHECK 31
LDNW 20
INC
LDLW 20
LOADW
NCHECK 31
STNW 20
RETURN
LABEL 3
!   ELSIF s < p.word THEN
LINE 32
LDLW 20
LOADW
NCHECK 32
CONST 20
SWAP
LDLW 16
LDLW 12
CONST COMPARE
CALLW 4
JGEQZ 4
!     IncWord(s, p.left)
LINE 33
LDLW 20
LOADW
NCHECK 33
CONST 24
PLUSA
LDLW 16
LDLW 12
CONST L14Words.IncWord
CALL 3
RETURN
LABEL 4
!     IncWord(s, p.right)
LINE 35
LDLW 20
LOADW
NCHECK 35
CONST 28
PLUSA
LDLW 16
LDLW 12
CONST L14Words.IncWord
CALL 3
RETURN
END

PROC L14Words.Output 1001 20 L14Words.Output.%map
! PROCEDURE Output(p: Tree);
LINE 52
!   sp := 0;
LINE 56
CONST 0
STLW -4
JUMP 8
LABEL 7
!       stack[sp] := p; sp := sp+1;
LINE 59
LDLW 12
LOCAL -4004
LDLW -4
CONST 1000
BOUND 59
STIW
INCL -4
!       p := p.left
LINE 60
LDLW 12
NCHECK 60
LDNW 24
STLW 12
LABEL 8
!     WHILE p # NIL DO
LINE 58
LDLW 12
JNEQZ 7
!     IF sp = 0 THEN EXIT END;
LINE 63
LDLW -4
JEQZ 6
!     sp := sp-1; p := stack[sp];
LINE 65
DECL -4
LOCAL -4004
LDLW -4
CONST 1000
BOUND 65
LDIW
STLW 12
!     Out.Int(p.count, 7); Out.Char(' '); Out.String(p.word); Out.Ln;
LINE 66
CONST 7
LDLW 12
NCHECK 66
LDNW 20
CONST Out.Int
CALL 2
CONST 32
ALIGNC
CONST Out.Char
CALL 1
LDLW 12
NCHECK 66
CONST 20
SWAP
CONST Out.String
CALL 2
CONST Out.Ln
CALL 0
!     p := p.right
LINE 67
LDLW 12
NCHECK 67
LDNW 28
STLW 12
JUMP 8
LABEL 6
RETURN
END

PROC L14Words.Main 6 20 0x00000801
! PROCEDURE Main;
LINE 71
!   root := NIL;
LINE 75
CONST 0
STLW -24
LABEL 11
!     In.Line(word);
LINE 78
CONST 20
LOCAL -20
CONST In.Line
CALL 2
!     IF ~In.Done THEN EXIT END;
LINE 79
LDGC In.Done
JUMPF 12
!     IncWord(word, root)
LINE 80
LOCAL -24
CONST 20
LOCAL -20
CONST L14Words.IncWord
CALL 3
JUMP 11
LABEL 12
!   Output(root)
LINE 83
LDLW -24
CONST L14Words.Output
CALL 1
RETURN
END

PROC L14Words.%main 0 20 0
!   Main
LINE 87
CONST L14Words.Main
CALL 0
RETURN
END

! Descriptor for Node
DEFINE L14Words.Node
WORD 0x00000181
WORD 0
WORD L14Words.Node.%anc

DEFINE L14Words.Node.%anc
WORD L14Words.Node

! Pointer maps
DEFINE L14Words.Output.%map
WORD 76
WORD GC_BLOCK
WORD -3940
WORD 1000
WORD GC_END

! End of file
